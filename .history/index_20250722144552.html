<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>

  <title>Erei</title>
  <style>
    body {
      font-family: sans-serif;
      background: #ffffff;
      color: #111;
      margin: 0;
      padding: 0;
    }
    #main {
    display: flex;
    flex-direction: column;
    height: 96vh;
    max-width: 800px;
    margin: auto;
    
    }

    .video-info {
    display: flex;
    gap: 20px;
    margin-top: 8px;
    font-size: 0.8em;
    color: #6e6e6e;
    align-items: center;
    }

        .video-info span {
        display: flex;
        align-items: center;
        gap: 6px;
        }

        .video-info svg {
        width: 16px;
        height: 16px;
        fill: #555;
        }

    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        }


    .video-container video {
      width: 100%;
      border-radius: 8px;
    }

    .video-container {
  flex-shrink: 0;
  padding: 15px;
  
  
}

.related-item.active {
  background-color: #f0f0f0;
  border-left: 4px solid #EA5B5B;
  border-radius: 4px;
  padding-left: 10px;
}

    .video-title {
      font-weight: bold;
      font-size: 1.3em;
      margin-top: 10px;
    }
    
    /* üÜï TABS STYLING */
    .tabs-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background-color: #f5f5f5;
    }

    .tabs-header {
      display: flex;
      background-color: #ffffff;
      border-bottom: 1px solid #e0e0e0;
      margin: 0 15px;
      flex-shrink: 0;
    }

    .tab-btn {
      flex: 1;
      padding: 15px 20px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #666;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
    }

    .tab-btn:hover {
      color: #333;
      background-color: #f8f9fa;
    }

    .tab-btn.active {
      color: #EA5B5B;
      border-bottom-color: #EA5B5B;
      background-color: #fff;
    }

    .tab-btn iconify-icon {
      font-size: 18px;
    }

    .tabs-content {
      flex-grow: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .tab-content {
      display: none;
      flex-grow: 1;
      overflow-y: auto;
      padding: 15px;
      padding-right: 5px;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* RELATED VIDEOS - TU C√ìDIGO ORIGINAL */
    .related-list {
      flex-grow: 1;
      overflow-y: auto;
    }
    
    .related-item {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      cursor: pointer;
      background: #ffffff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s ease;
    }

    .related-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .related-item img {
      width: 140px;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
    }
    .related-texts {
      flex-grow: 1;
    }
    .related-texts .name {
      font-weight: bold;
      font-size: 0.9em;
    }
    .related-texts .duration {
      font-size: 0.9em;
      color: #555;
    }

    /* üÜï COMMENTS STYLING */
    .comments-container {
      flex-grow: 1;
      overflow-y: auto;
    }

    .comment-form {
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      flex-shrink: 0;
    }

    .user-info {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }

    .instructor-badge {
      background: #28a745;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      margin-left: 8px;
    }

    .comment-form textarea {
      width: 100%;
      min-height: 80px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      box-sizing: border-box;
    }

    .comment-form textarea:focus {
      outline: none;
      border-color: #EA5B5B;
    }

    .comment-form button {
      background: #EA5B5B;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      margin-top: 10px;
    }

    .comment-form button:hover {
      background: #d44848;
    }

    .comment-thread {
      margin-bottom: 20px;
      background: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .comment {
      padding: 15px;
      border-bottom: 1px solid #f0f0f0;
    }

    .comment:last-child {
      border-bottom: none;
    }

    .main-comment {
      background: #f8f9fa;
    }

    .reply-comment {
      background: #ffffff;
      margin-left: 20px;
      border-left: 3px solid #EA5B5B;
      padding-left: 15px;
    }

    .comment-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .comment-header strong {
      color: #333;
    }

    .comment-time {
      color: #999;
      font-size: 12px;
    }

    .comment-message {
      color: #444;
      line-height: 1.4;
      margin-bottom: 10px;
    }

    .comment-actions button {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 12px;
      padding: 4px 8px;
    }

    .comment-actions button:hover {
      color: #EA5B5B;
    }

    .reply-form {
      padding: 15px;
      background: #f8f9fa;
      border-top: 1px solid #e0e0e0;
    }

    .reply-form textarea {
      width: 100%;
      min-height: 60px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    .reply-form button {
      background: #EA5B5B;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-right: 10px;
    }

    .reply-form button:last-child {
      background: #6c757d;
    }

    canvas {
      display: none;
    }

    /* Empty states */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }

    .empty-state iconify-icon {
      font-size: 48px;
      color: #ccc;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div id="main">
    <!-- Video Container -->
    <div class="video-container">
      <video id="mainVideo" controls autoplay crossorigin="anonymous" playsinline></video>
      <div class="video-title" id="mainTitle"></div>
      <div class="video-info" id="mainInfo"></div>
    </div>

    <!-- Tabs Container -->
    <div class="tabs-container">
      <!-- Tabs Header -->
      <div class="tabs-header">
        <button class="tab-btn active" data-tab="comments">
          <iconify-icon icon="mdi:comment-multiple"></iconify-icon>
          Comentarios
        </button>
        <button class="tab-btn" data-tab="related">
          <iconify-icon icon="mdi:playlist-play"></iconify-icon>
          Otros videos
        </button>
      </div>

      <!-- Tabs Content -->
      <div class="tabs-content">
        <!-- Comments Tab -->
        <div id="comments-tab" class="tab-content active">
          <!-- Comment Form -->
          <div class="comment-form">
            <div class="user-info" id="userInfo">
              Comentando como: <strong>Cargando...</strong>
            </div>
            <textarea id="new-comment" placeholder="Escribe tu comentario..."></textarea>
            <button onclick="CommentsManager.submitNewComment()">
              Enviar Comentario
            </button>
          </div>

          <!-- Comments List -->
          <div class="comments-container">
            <div id="comments-list">
              <!-- Los comentarios se cargan aqu√≠ din√°micamente -->
            </div>
          </div>
        </div>

        <!-- Related Videos Tab -->
        <div id="related-tab" class="tab-content">
          <div class="related-list" id="relatedList">
            <!-- Tu c√≥digo existente de videos relacionados se carga aqu√≠ -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <canvas id="captureCanvas"></canvas>

    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

        // üéõÔ∏è CONFIGURACI√ìN PRINCIPAL
        const ENABLE_PREVIEW_PROCESSING = false // ‚ö° Cambiar a true para procesar previews

        const supabase = createClient(
        'https://heuqktyjmrhivmdrbspo.supabase.co',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhldXFrdHlqbXJoaXZtZHJic3BvIiwicm9sZSI6ImFub24iLCJpYXQiOjE2ODI2MjE0MzcsImV4cCI6MTk5ODE5NzQzN30.VWtsaZwks1WVx1_KH8GjFG85wavsSMV4YWfbEF66BBg'
        )

        const urlParams = new URLSearchParams(window.location.search)
        const program = urlParams.get('program') || '1'
        const currentId = urlParams.get('current') || '1'

        // üÜï DATOS DE USUARIO
        const currentUser = {
          id: urlParams.get('user_id') || 'user123',
          name: decodeURIComponent(urlParams.get('user_name') || 'Usuario Demo'),
          isInstructor: urlParams.get('is_instructor') === 'true'
        }

        console.log('üë§ Usuario actual:', currentUser)

        // üÜï GESTOR DE TABS
        const TabsManager = {
          init() {
            const tabButtons = document.querySelectorAll('.tab-btn')
            
            tabButtons.forEach(button => {
              button.addEventListener('click', () => {
                const tabName = button.getAttribute('data-tab')
                this.switchTab(tabName)
              })
            })
          },

          switchTab(tabName) {
            // Actualizar botones
            document.querySelectorAll('.tab-btn').forEach(btn => {
              btn.classList.remove('active')
            })
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active')

            // Actualizar contenido
            document.querySelectorAll('.tab-content').forEach(content => {
              content.classList.remove('active')
            })
            document.getElementById(`${tabName}-tab`).classList.add('active')

            console.log(`üì± Cambiado a tab: ${tabName}`)
          }
        }

        // üÜï GESTOR DE COMENTARIOS
        const CommentsManager = {
          getCurrentUser() {
            return currentUser
          },

          init() {
            this.updateUserInfo()
            this.loadComments(currentId)
          },

          updateUserInfo() {
            const user = this.getCurrentUser()
            const userInfoEl = document.getElementById('userInfo')
            
            userInfoEl.innerHTML = `
              Comentando como: <strong>${user.name}</strong>
              ${user.isInstructor ? '<span class="instructor-badge">üë®‚Äçüè´ Instructor</span>' : ''}
            `
          },

          async loadComments(videoId) {
            try {
              console.log(`üí¨ Cargando comentarios para video ${videoId}`)
              
              const { data: comments, error } = await supabase
                .from('comments')
                .select('*')
                .eq('video_id', videoId)
                .order('created_at', { ascending: false })

              if (error) {
                console.error('Error cargando comentarios:', error)
                return
              }

              console.log(`üìù ${comments?.length || 0} comentarios encontrados`)
              
              const grouped = this.groupComments(comments || [])
              this.renderComments(grouped)
              
            } catch (error) {
              console.error('Error en loadComments:', error)
            }
          },

          groupComments(comments) {
            const grouped = []
            const commentMap = {}
            
            // Crear mapa de comentarios
            comments.forEach(comment => {
              commentMap[comment.id] = { ...comment, replies: [] }
            })
            
            // Agrupar respuestas
            comments.forEach(comment => {
              if (comment.parent_id === null) {
                // Comentario principal
                grouped.push(commentMap[comment.id])
              } else {
                // Respuesta - agregar al comentario principal
                const parentComment = commentMap[comment.parent_id]
                if (parentComment) {
                  parentComment.replies.push(commentMap[comment.id])
                }
              }
            })
            
            return grouped
          },

          renderComments(groupedComments) {
            const container = document.getElementById('comments-list')
            
            if (groupedComments.length === 0) {
              container.innerHTML = `
                <div class="empty-state">
                  <iconify-icon icon="mdi:comment-outline"></iconify-icon>
                  <p>No hay comentarios a√∫n</p>
                  <p>¬°S√© el primero en comentar!</p>
                </div>
              `
              return
            }
            
            container.innerHTML = groupedComments.map(comment => 
              this.createCommentHTML(comment)
            ).join('')
          },

          createCommentHTML(comment) {
            return `
              <div class="comment-thread">
                <div class="comment main-comment">
                  <div class="comment-header">
                    <strong>${comment.user_name}</strong>
                    ${comment.is_instructor ? '<span class="instructor-badge">üë®‚Äçüè´ Instructor</span>' : ''}
                    <span class="comment-time">${this.formatTime(comment.created_at)}</span>
                  </div>
                  <div class="comment-message">${comment.message}</div>
                  <div class="comment-actions">
                    ${this.getCurrentUser().isInstructor ? `
                      <button onclick="CommentsManager.showReplyForm(${comment.id})">
                        üí¨ Responder
                      </button>
                    ` : ''}
                  </div>
                </div>
                
                ${comment.replies.map(reply => `
                  <div class="comment reply-comment">
                    <div class="comment-header">
                      <strong>${reply.user_name}</strong>
                      ${reply.is_instructor ? '<span class="instructor-badge">üë®‚Äçüè´ Instructor</span>' : ''}
                      <span class="comment-time">${this.formatTime(reply.created_at)}</span>
                    </div>
                    <div class="comment-message">${reply.message}</div>
                  </div>
                `).join('')}
                
                <div id="reply-form-${comment.id}" class="reply-form" style="display: none;">
                  <textarea placeholder="Escribe tu respuesta como instructor..."></textarea>
                  <button onclick="CommentsManager.submitReply(${comment.id})">Enviar Respuesta</button>
                  <button onclick="CommentsManager.hideReplyForm(${comment.id})">Cancelar</button>
                </div>
              </div>
            `
          },

          formatTime(dateString) {
            const date = new Date(dateString)
            const now = new Date()
            const diffMs = now - date
            const diffMins = Math.floor(diffMs / 60000)
            const diffHours = Math.floor(diffMins / 60)
            const diffDays = Math.floor(diffHours / 24)

            if (diffMins < 1) return 'Ahora'
            if (diffMins < 60) return `${diffMins}m`
            if (diffHours < 24) return `${diffHours}h`
            if (diffDays < 7) return `${diffDays}d`
            
            return date.toLocaleDateString('es-ES', { 
              day: 'numeric', 
              month: 'short' 
            })
          },

          async submitNewComment() {
            const textarea = document.getElementById('new-comment')
            const message = textarea.value.trim()
            
            if (!message) {
              alert('Por favor escribe un comentario')
              return
            }

            await this.addComment(currentId, message)
            textarea.value = ''
          },

          async addComment(videoId, message, parentId = null) {
            const user = this.getCurrentUser()
            
            // Validar si puede responder
            if (parentId && !user.isInstructor) {
              alert('Solo el instructor puede responder a comentarios')
              return
            }

            try {
              const { data, error } = await supabase
                .from('comments')
                .insert({
                  video_id: parseInt(videoId),
                  message,
                  parent_id: parentId,
                  user_id: user.id,
                  user_name: user.name,
                  is_instructor: user.isInstructor
                })

              if (error) {
                console.error('Error agregando comentario:', error)
                alert('Error al enviar comentario')
                return
              }

              console.log('‚úÖ Comentario agregado:', data)
              this.loadComments(videoId)
              
            } catch (error) {
              console.error('Error en addComment:', error)
              alert('Error al enviar comentario')
            }
          },

          showReplyForm(commentId) {
            const user = this.getCurrentUser()
            
            if (!user.isInstructor) {
              alert('Solo el instructor puede responder a comentarios')
              return
            }
            
            document.getElementById(`reply-form-${commentId}`).style.display = 'block'
          },

          hideReplyForm(commentId) {
            document.getElementById(`reply-form-${commentId}`).style.display = 'none'
          },

          async submitReply(commentId) {
            const replyForm = document.getElementById(`reply-form-${commentId}`)
            const textarea = replyForm.querySelector('textarea')
            const message = textarea.value.trim()
            
            if (!message) {
              alert('Por favor escribe una respuesta')
              return
            }

            await this.addComment(currentId, message, commentId)
            textarea.value = ''
            this.hideReplyForm(commentId)
          }
        }

        // =====================================================
        // üî• TODO TU C√ìDIGO ORIGINAL AQU√ç - SIN CAMBIOS
        // =====================================================

        const relatedItemsRefs = []
        const videoElement = document.getElementById('mainVideo')
        const canvas = document.getElementById('captureCanvas')
        const ctx = canvas.getContext('2d')

        const listEl = document.getElementById('relatedList')
        const titleEl = document.getElementById('mainTitle')

        // üì¶ M√ìDULO DE PROCESAMIENTO DE PREVIEWS
        const PreviewProcessor = {
            // Funci√≥n para verificar si una imagen es "negra" o vac√≠a
            isImageBlackOrEmpty(canvas, ctx) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
                const data = imageData.data
                
                let totalBrightness = 0
                let pixelCount = 0
                
                // Muestrear cada 4to pixel para performance
                for (let i = 0; i < data.length; i += 16) {
                    const r = data[i]
                    const g = data[i + 1]
                    const b = data[i + 2]
                    const brightness = (r + g + b) / 3
                    totalBrightness += brightness
                    pixelCount++
                }
                
                const avgBrightness = totalBrightness / pixelCount
                console.log(`üîç Brightness promedio: ${avgBrightness.toFixed(2)}/255`)
                
                return avgBrightness < 20
            },

            // Funci√≥n principal para generar preview y obtener duraci√≥n
            async getPreviewAndDuration(videoUrl, maxRetries = 5) {
                return new Promise((resolve) => {
                    let currentRetry = 0
                    
                    const attemptCapture = () => {
                        currentRetry++
                        console.log(`\nüé¨ INTENTO ${currentRetry}/${maxRetries} para: ${videoUrl}`)
                        
                        const tempVideo = document.createElement('video')
                        tempVideo.crossOrigin = 'anonymous'
                        tempVideo.src = videoUrl
                        tempVideo.muted = true
                        tempVideo.playsInline = true
                        tempVideo.preload = 'auto'
                        
                        let hasResolved = false
                        let captureAttempts = 0
                        
                        const resolveOnce = (result) => {
                            if (!hasResolved) {
                                hasResolved = true
                                console.log(`‚úÖ Resolviendo con: preview=${result.preview ? 'S√ç' : 'NO'}, duration=${result.duration}`)
                                resolve(result)
                            }
                        }

                        const tryCapture = () => {
                            captureAttempts++
                            const duration = tempVideo.duration || 0
                            
                            if (duration === 0) {
                                console.warn(`‚ö†Ô∏è  Duraci√≥n es 0 para: ${videoUrl}`)
                                if (currentRetry < maxRetries) {
                                    console.log(`üîÑ Reintentando en 2 segundos...`)
                                    setTimeout(attemptCapture, 2000)
                                    return
                                } else {
                                    resolveOnce({ preview: '', duration: 0 })
                                    return
                                }
                            }
                            
                            // Probar m√∫ltiples tiempos de captura
                            const captureTimes = [
                                Math.min(3, duration * 0.05),   // 5% del video
                                Math.min(5, duration * 0.1),    // 10% del video
                                Math.min(10, duration * 0.2),   // 20% del video
                                Math.min(15, duration * 0.3),   // 30% del video
                                Math.min(20, duration * 0.5)    // 50% del video
                            ]
                            
                            const captureTime = captureTimes[Math.min(captureAttempts - 1, captureTimes.length - 1)]
                            
                            console.log(`‚è∞ Capturando en tiempo: ${captureTime.toFixed(2)}s de ${duration.toFixed(2)}s total`)
                            console.log(`üìä Video dimensiones: ${tempVideo.videoWidth}x${tempVideo.videoHeight}`)
                            console.log(`üì∂ ReadyState: ${tempVideo.readyState} (4=HAVE_ENOUGH_DATA)`)
                            
                            tempVideo.currentTime = captureTime
                        }

                        tempVideo.addEventListener('loadedmetadata', () => {
                            console.log(`üìù Metadata cargada:`)
                            console.log(`   - Duraci√≥n: ${tempVideo.duration}s`)
                            console.log(`   - Dimensiones: ${tempVideo.videoWidth}x${tempVideo.videoHeight}`)
                            console.log(`   - ReadyState: ${tempVideo.readyState}`)
                        })

                        tempVideo.addEventListener('loadeddata', () => {
                            console.log(`üì¶ Data cargada, ReadyState: ${tempVideo.readyState}`)
                            if (!hasResolved) {
                                setTimeout(tryCapture, 1000)
                            }
                        })

                        tempVideo.addEventListener('seeked', () => {
                            console.log(`üé™ Video seeked a tiempo: ${tempVideo.currentTime}s`)
                            
                            if (tempVideo.videoWidth === 0 || tempVideo.videoHeight === 0) {
                                console.warn(`‚ùå Video sin dimensiones v√°lidas: ${tempVideo.videoWidth}x${tempVideo.videoHeight}`)
                                
                                if (captureAttempts < 5) {
                                    console.log(`üîÑ Reintentando captura...`)
                                    setTimeout(tryCapture, 1000)
                                    return
                                } else if (currentRetry < maxRetries) {
                                    console.log(`üîÑ Reintentando todo el video...`)
                                    setTimeout(attemptCapture, 2000)
                                    return
                                } else {
                                    resolveOnce({ preview: '', duration: tempVideo.duration || 0 })
                                    return
                                }
                            }

                            try {
                                canvas.width = 320
                                canvas.height = 180
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height)
                                ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height)
                                
                                // VERIFICAR SI LA IMAGEN ES NEGRA
                                const isBlack = this.isImageBlackOrEmpty(canvas, ctx)
                                
                                if (isBlack) {
                                    console.log(`üñ§ Imagen capturada es NEGRA o vac√≠a en intento ${captureAttempts}`)
                                    
                                    if (captureAttempts < 5) {
                                        console.log(`üîÑ Probando otro tiempo de captura...`)
                                        setTimeout(tryCapture, 1000)
                                        return
                                    } else if (currentRetry < maxRetries) {
                                        console.log(`üîÑ Imagen negra persistente, reintentando todo el video...`)
                                        setTimeout(attemptCapture, 2000)
                                        return
                                    } else {
                                        console.log(`üíÄ Todas las capturas fueron negras, guardando duraci√≥n solamente`)
                                        resolveOnce({ preview: '', duration: tempVideo.duration || 0 })
                                        return
                                    }
                                }
                                
                                const preview = canvas.toDataURL('image/jpeg', 0.8)
                                const duration = tempVideo.duration
                                
                                console.log(`üéâ √âXITO! Preview generado correctamente`)
                                console.log(`   - Preview size: ${preview.length} characters`)
                                console.log(`   - Duraci√≥n: ${duration}s`)
                                
                                resolveOnce({ preview, duration })
                                
                            } catch (error) {
                                console.error(`üí• Error capturando frame:`, error)
                                
                                if (captureAttempts < 5) {
                                    setTimeout(tryCapture, 1000)
                                    return
                                } else if (currentRetry < maxRetries) {
                                    setTimeout(attemptCapture, 2000)
                                    return
                                } else {
                                    resolveOnce({ preview: '', duration: tempVideo.duration || 0 })
                                }
                            }
                        })

                        tempVideo.addEventListener('error', (e) => {
                            console.error(`üí• ERROR de video:`, e.target.error, videoUrl)
                            
                            if (currentRetry < maxRetries) {
                                console.log(`üîÑ Reintentando por error...`)
                                setTimeout(attemptCapture, 3000)
                                return
                            } else {
                                resolveOnce({ preview: '', duration: 0 })
                            }
                        })

                        // Timeout por intento
                        setTimeout(() => {
                            if (!hasResolved) {
                                console.warn(`‚è∞ Timeout alcanzado para intento ${currentRetry}`)
                                if (currentRetry < maxRetries) {
                                    setTimeout(attemptCapture, 1000)
                                } else {
                                    resolveOnce({ preview: '', duration: 0 })
                                }
                            }
                        }, 20000)
                        
                        console.log(`üöÄ Iniciando carga del video...`)
                        tempVideo.load()
                    }
                    
                    attemptCapture()
                })
            },

            // Funci√≥n para subir preview a Supabase Storage
            async uploadPreviewToStorage(base64Image, fileName) {
                try {
                    console.log(`üì§ Subiendo preview para: ${fileName}`)
                    const base64Data = base64Image.split(',')[1]
                    const file = new Blob([Uint8Array.from(atob(base64Data), c => c.charCodeAt(0))], { type: 'image/jpeg' })

                    const { data, error } = await supabase.storage
                        .from('storage')
                        .upload(`previews/${fileName}.jpg`, file, { upsert: true })

                    if (error) {
                        console.error('‚ùå Error al subir imagen:', error)
                        return ''
                    }

                    const { data: publicUrl } = supabase.storage
                        .from('storage')
                        .getPublicUrl(`previews/${fileName}.jpg`)

                    console.log(`‚úÖ Preview subido: ${publicUrl.publicUrl}`)
                    return publicUrl.publicUrl
                } catch (error) {
                    console.error('üí• Error in uploadPreviewToStorage:', error)
                    return ''
                }
            },

            // Funci√≥n principal que procesa un video completo
            async processVideo(item) {
                if (!ENABLE_PREVIEW_PROCESSING) {
                    console.log(`‚è≠Ô∏è  Procesamiento deshabilitado para: ${item.name}`)
                    return { preview: item.preview, duration: item.duration }
                }

                console.log(`üîß INICIANDO PROCESAMIENTO DE: ${item.name}`)
                
                try {
                    const result = await this.getPreviewAndDuration(item.url_video)
                    
                    console.log(`üìä RESULTADO:`)
                    console.log(`   - Preview obtenido: ${result.preview ? 'S√ç (' + result.preview.length + ' chars)' : 'NO'}`)
                    console.log(`   - Duraci√≥n obtenida: ${result.duration}s`)
                    
                    let preview = result.preview
                    let duration = result.duration
                    const fileName = `video_${item.id}`
                    let publicUrl = item.preview

                    if (preview && preview.startsWith('data:image')) {
                        publicUrl = await this.uploadPreviewToStorage(preview, fileName)

                        await supabase
                        .from('class_virtual')
                        .update({ preview: publicUrl, duration })
                        .eq('id', item.id)

                        preview = publicUrl
                    } else if (!preview && duration) {
                        await supabase
                        .from('class_virtual')
                        .update({ duration })
                        .eq('id', item.id)
                    }

                    return { preview, duration }
                } catch (error) {
                    console.error(`üí• ERROR PROCESANDO ${item.name}:`, error)
                    throw error
                }
            }
        }

        const formatDuration = (seconds) => {
        if (!seconds || isNaN(seconds)) return 'N/A'
        const m = Math.floor(seconds / 60)
        const s = Math.floor(seconds % 60)
        return `${m}:${s < 10 ? '0' : ''}${s}`
        }

        const loadData = async () => {
        const { data: items, error } = await supabase
            .from('class_virtual')
            .select('*')
            .eq('program', program)

        if (error) {
            console.error(error)
            return
        }

        // Encontrar el video actual
        const currentItem = items.find(item => item.id == currentId)
        if (!currentItem) {
            titleEl.innerText = 'Video no encontrado.'
            return
        }

        // üéØ FILTRAR POR TIPO (solo mostrar videos del mismo tipo que el actual)
        const filteredItems = items.filter(item => item.type === currentItem.type)
        console.log(`üé≠ Filtrando por type="${currentItem.type}": ${filteredItems.length}/${items.length} videos`)

        videoElement.src = currentItem.url_video
        titleEl.innerText = currentItem.name
     
        document.getElementById('mainInfo').innerHTML = `
            <span>
                <iconify-icon icon="mdi:clock-time-four-outline" style="font-size:13px;"></iconify-icon>
                Duraci√≥n: ${formatDuration(currentItem.duration)}
            </span>
            <span>
                <iconify-icon icon="mdi:arm-flex-outline" style="font-size:13px;"></iconify-icon>
                Dificultad: ${currentItem.dificult || 'N/A'}
            </span>
            `

        console.log(`\nüé¨ CARGANDO ${filteredItems.length} VIDEOS DEL TIPO "${currentItem.type}":`)
        console.log(`üìù Procesamiento de previews: ${ENABLE_PREVIEW_PROCESSING ? '‚úÖ HABILITADO' : '‚ùå DESHABILITADO'}`)
        
        // Procesar solo videos filtrados
        for (let i = 0; i < filteredItems.length; i++) {
            const item = filteredItems[i]
            
            console.log(`\nüìã ======== VIDEO ${i + 1}/${filteredItems.length}: ${item.name} ========`)
            console.log(`üîó URL: ${item.url_video}`)
            console.log(`üé≠ Tipo: ${item.type}`)
            console.log(`üñºÔ∏è  Preview actual: ${item.preview ? 'S√ç' : 'NO'}`)
            console.log(`‚è±Ô∏è  Duraci√≥n actual: ${item.duration || 'NO'}`)
            
            const div = document.createElement('div')
            div.className = 'related-item'
            if (item.id == currentId) div.classList.add('active')
            relatedItemsRefs.push({ id: item.id, el: div })

            div.onclick = async () => {
                history.replaceState(null, '', `${window.location.pathname}?program=${program}&current=${item.id}&user_id=${currentUser.id}&user_name=${encodeURIComponent(currentUser.name)}&is_instructor=${currentUser.isInstructor}`)

                videoElement.src = item.url_video
                titleEl.innerText = item.name
                await videoElement.play()
                
                document.getElementById('mainInfo').innerHTML = `
                    <span>
                        <iconify-icon icon="mdi:clock-time-four-outline" style="font-size:13px;"></iconify-icon>
                        Duraci√≥n: ${formatDuration(item.duration)}
                    </span>
                    <span>
                        <iconify-icon icon="mdi:arm-flex-outline" style="font-size:13px;"></iconify-icon>
                        Dificultad: ${item.dificult || 'N/A'}
                    </span>
                    `

                relatedItemsRefs.forEach(ref => {
                ref.el.classList.toggle('active', ref.id == item.id)
                })

                // üÜï Actualizar comentarios al cambiar video
                CommentsManager.loadComments(item.id)
            }

            const img = document.createElement('img')
            img.style.background = '#f0f0f0'
            img.alt = 'Preview'

            const texts = document.createElement('div')
            texts.className = 'related-texts'
            texts.innerHTML = `
            <div class="name">${item.name}</div>
            <div class="duration">Duraci√≥n: ${formatDuration(item.duration)}</div>
            `

            div.appendChild(img)
            div.appendChild(texts)
            listEl.appendChild(div)

            let preview = item.preview
            let duration = item.duration

            // Solo procesar si no tiene datos O si el procesamiento est√° habilitado
            if ((!preview || !duration) && ENABLE_PREVIEW_PROCESSING) {
                texts.querySelector('.duration').innerText = 'üîÑ Procesando...'
                
                try {
                    const result = await PreviewProcessor.processVideo(item)
                    preview = result.preview
                    duration = result.duration
                } catch (error) {
                    console.error(`üí• ERROR PROCESANDO ${item.name}:`, error)
                    texts.querySelector('.duration').innerText = 'Error al procesar'
                    continue
                }
            }

            if (preview) {
                img.src = preview
                console.log(`üñºÔ∏è  Preview asignado a imagen`)
            } else {
                img.style.background = '#ddd'
                img.alt = 'Sin preview'
                console.log(`‚ùå No hay preview para mostrar`)
            }
            
            texts.querySelector('.duration').innerText = `Duraci√≥n: ${formatDuration(duration)}`
            
            console.log(`‚úÖ ======== COMPLETADO VIDEO ${i + 1} ========\n`)
            
            // Pausa entre videos solo si est√° procesando
            if (ENABLE_PREVIEW_PROCESSING && i < filteredItems.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000))
            }
        }
        
        console.log(`üéâ ======== TODOS LOS VIDEOS PROCESADOS ========`)
        }

        // üöÄ INICIALIZACI√ìN
        document.addEventListener('DOMContentLoaded', () => {
          TabsManager.init()
          CommentsManager.init()
          loadData()
        })

        // Hacer CommentsManager global para los botones
        window.CommentsManager = CommentsManager
    </script>
    
</body>
</html>